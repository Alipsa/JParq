
**Please add support for the GROUPING SETS as described in the SQL:1999/2003 standard.**
GROUPING SETS is a standard SQL feature (introduced in SQL:1999/2003) that allows you to define multiple, independent grouping specifications within a single GROUP BY clause. Its primary purpose is to calculate various levels of aggregation (subtotals and grand totals) in one query, which greatly simplifies complex analytical and reporting tasks.

# Key Characteristics According to the SQL Standard:
Instead of calculating a single aggregation (e.g., total sales by City), GROUPING SETS tells the database to calculate several specified aggregations (e.g., total sales by City, total sales by Year, and total sales overall) and combine them into one result set.

## Syntax:
```sql
SELECT 
    column_A, 
    column_B, 
    Aggregate_Function(column_C)
FROM 
    TableName
GROUP BY 
    GROUPING SETS (
        (column_A, column_B), -- Group 1: Subtotal by A and B
        (column_A),           -- Group 2: Subtotal by A only
        (column_B),           -- Group 3: Subtotal by B only
        ()                    -- Group 4: Grand total (empty set)
    );
```

## The GROUPING Function
The SQL standard provides the GROUPING(column) function to identify which rows are summary rows generated by the GROUPING SETS clause, as opposed to true detail rows where the column naturally contains NULL.

Output: GROUPING(column) returns 1 if the column is currently being aggregated (i.e., it holds a summary NULL value) and 0 if the column is part of the current grouping set.

# Example using the mtcars Dataset
We will use GROUPING SETS to calculate the Total Horsepower (hp) based on three separate groupings in a single query:

- By Cylinders and Gears (cyl, gear).
- By Cylinders only (cyl).
- Grand Total (()).

```sql
SELECT
    cyl,
    gear,
    SUM(hp) AS Total_HP,
    -- Use GROUPING to label the subtotals
    CASE 
        WHEN GROUPING(cyl) = 0 AND GROUPING(gear) = 0 THEN 'Detail Subtotal'
        WHEN GROUPING(cyl) = 0 THEN 'CYLINDER TOTAL'
        ELSE 'GRAND TOTAL'
    END AS Group_Level
FROM
    mtcars
GROUP BY
    GROUPING SETS (
        (cyl, gear),  -- Group 1: Subtotal by both (detailed)
        (cyl),        -- Group 2: Subtotal by cylinders only
        ()            -- Group 3: Grand Total
    )
ORDER BY
    cyl, gear;
```
Example Output (Partial)
```
cyl,gear,Total_HP,Group_Level
4,3,109,Detail Subtotal
4,4,487,Detail Subtotal
4,5,113,Detail Subtotal
4,NULL,709,CYLINDER TOTAL
6,3,243,Detail Subtotal
6,4,120,Detail Subtotal
6,5,175,Detail Subtotal
6,NULL,538,CYLINDER TOTAL
...,...,...,...
8,3,2408,Detail Subtotal
8,5,674,Detail Subtotal
8,NULL,3082,CYLINDER TOTAL
NULL,NULL,4329,GRAND TOTAL
...,...,...,
```

Explanation of the Result
- Detail Subtotals: Rows where both cyl and gear are present (non-NULL) show the Total_HP for that specific combination (e.g., 4-cyl, 4-gear cars have 487 HP total).
- Cylinder Totals: Rows where gear is NULL (and GROUPING(gear) returns 1) represent the total hp for that cylinder type across all gears (e.g., all 4-cylinder cars total 709 HP).
- Grand Total: The final row, where both cyl and gear are NULL, represents the total hp across the entire dataset (4329).


# Important!
- Create tests to verify the functionality in a test class called jparq.group.GroupingSetsTest
- Remember to also update javadocs (all classes and methods must have a description, all params must be listed and return and throws specified when appropriate) where needed.
- Adhere to the coding standard defined in checkstyle.xml, pmd-ruleset.xml and spotless-formatting.xml and also pay attention to the design principles of low coupling, high cohesion, clarity and DRY (don't repeat yourself).
- All tests must pass after the implementation using `mvn -Dspotless.check.skip=true verify` to ensure that there is no regression.
- No checkstyle, PMD or Spotless violations shall be present after the implementation.
