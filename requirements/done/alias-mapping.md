# SELECT evaluation flow and qualifier handling

## Projection and record-level evaluation
- **Select processing** uses `QueryProcessor` to apply projection, WHERE, DISTINCT, LIMIT/OFFSET, and ORDER BY against a `RecordReader`. The processor builds `ValueExpressionEvaluator` instances for projections and ORDER BY expressions, passing along any qualifier-to-column mappings gathered from the reader. 【F:src/main/java/se/alipsa/jparq/engine/QueryProcessor.java†L363-L610】
- **Column resolution inside projections** flows through `ValueExpressionEvaluator`, which delegates to `ColumnMappingUtil.canonicalFieldName` when encountering a `Column` expression. The evaluator relies on its `qualifierColumnMapping` and `unqualifiedColumnMapping` inputs to translate qualified references back to the canonical Avro field names for the current record. 【F:src/main/java/se/alipsa/jparq/engine/ValueExpressionEvaluator.java†L52-L165】【F:src/main/java/se/alipsa/jparq/engine/ValueExpressionEvaluator.java†L1295-L1333】
- **Canonical lookups** in `ColumnMappingUtil` fall back to a case-insensitive index when no qualifier mapping is available. This only succeeds when canonical field names match the unqualified column names; if canonical names were prefixed (e.g., to disambiguate duplicates), the qualifier mapping is required to recover the original column identifier. 【F:src/main/java/se/alipsa/jparq/engine/ColumnMappingUtil.java†L25-L119】【F:src/main/java/se/alipsa/jparq/engine/ColumnMappingUtil.java†L200-L217】

## Subquery execution utilities
- **Scalar and array subqueries** inside projections are evaluated by `ValueExpressionEvaluator` using `SubqueryExecutor`. Correlated subqueries are rewritten via `CorrelatedSubqueryRewriter`, which calls back into `resolveColumnValue` with a qualifier-aware lookup for each correlated reference. 【F:src/main/java/se/alipsa/jparq/engine/ValueExpressionEvaluator.java†L330-L540】
- **SubqueryExecutor** always executes with the JDBC connection and eagerly captures column labels and row values, but it does not carry any qualifier metadata from the outer query. The column-to-qualifier relationships must therefore be supplied by the outer evaluator’s mappings when correlated values are substituted. 【F:src/main/java/se/alipsa/jparq/engine/SubqueryExecutor.java†L15-L118】

## Where alias-to-column mappings disappear
- **Materializing derived tables and CTEs**: `JParqPreparedStatement` executes subqueries for derived tables/CTEs via `executeSubquery`, building an Avro schema from JDBC metadata (`buildSubquerySchema`) and wrapping the rows in an `InMemoryRecordReader` when the derived result becomes the sole source of the outer query. No qualifier-to-canonical mapping is attached to this in-memory reader. 【F:src/main/java/se/alipsa/jparq/JParqPreparedStatement.java†L270-L335】【F:src/main/java/se/alipsa/jparq/JParqPreparedStatement.java†L1610-L1685】【F:src/main/java/se/alipsa/jparq/JParqPreparedStatement.java†L1830-L1853】
- **Qualifier mapping drop**: `JParqResultSet` only receives qualifier mappings when the reader is a `JoinRecordReader`; for in-memory readers (used for derived tables/CTEs when no additional joins are present) it populates `qualifierColumnMapping` with an empty map. As a result, `ValueExpressionEvaluator` must rely solely on the case-insensitive index. When the derived schema prefixed canonical names to avoid collisions, qualified references such as `derived.department_id` can no longer be translated back to their canonical fields, causing resolution failures. 【F:src/main/java/se/alipsa/jparq/JParqResultSet.java†L110-L172】【F:src/main/java/se/alipsa/jparq/engine/ColumnMappingUtil.java†L25-L119】

## Impacted symptom
When an outer query projects from a derived table/CTE (materialized via `executeSubquery`) and correlates a scalar subquery on a qualified column like `derived.department_id`, the lack of qualifier-to-column mappings on the in-memory reader means `ColumnMappingUtil` cannot map the qualified reference back to the prefixed canonical field name. This manifests as errors such as `Unknown column 'department_id' for qualifier 'derived'` during scalar subquery evaluation.
